
// ---------------- Constants ----------------

/* Important global variables */
const DRONE_CLIENT_ID = 'INSERT_ID_HERE'; // ScaleDrone room id
let room; // Scaledrone room which we are subscribed to
let roomMembers = []; // Scaledrone room members
let localStream = null; // Video stream which we send to peers
let rtcServerMap = new Map();

// Prompt user to enter the room hash. The hash is randomly generated by the
// server.
let roomHash = '';
while (true) {
    roomHash = prompt("Enter ScaleDrone room hash");
    if (roomHash != null && roomHash != "") {
        break;
    }  
    else {
        alert("Please enter a room hash");
    }
}
//let roomHash = 'smitty_werbenjagermanjensen';

// Subscribe to room
const roomName = 'videostream-' + roomHash; // This hash code is what makes you need the URL. If set to a known value, it'll always be the same room
const observableRoomName = 'observable-' + roomName;

// Set location hash on the browser tab
if (!location.hash) {
    location.hash = '#' + roomHash;
}
document.getElementById("myHash").textContent = 'Hash: ' + roomHash;

// Configuration is passed to RTCPeerConnection instance. Use Google's STUN server
const ice_configuration = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' } // Google's public STUN server
    ]
};

// Prompt user to allow stream. This begins the local Video feed that will
// be given to the connected peers
async function startStream() {
    console.log('Requesting local stream');
    localStream = await navigator.mediaDevices.getUserMedia({video: true, audio: true});
    if (localStream == null) {
        throw new Error('Failed to receive local stream');
    }
    rtcServerMap.forEach(server => server.pc.addStream(localStream))
    console.log('Receiving local stream');
}
startStream();


// ---------------- Signalling Service Callbacks ----------------

const drone = new ScaleDrone(DRONE_CLIENT_ID, { data: { name: 'server' } });

// Subsribe to a Scaledrone room for signaling
drone.on('open', error => {
    if (error) {
        console.error(error);
        return;
    }
    
    // Subscribe to the ScaleDrone room.
    // Room name needs to be prefixed with 'observable-'
    room = drone.subscribe(observableRoomName);
    room.on('open', error => {
        if (error) {
            console.error(error);
        }
    });
    
    // Connected to room and receive array of members
    room.on('members', receivedMembers => {
        roomMembers = receivedMembers;
        updateMembersDOM();
        receivedMembers.forEach( (member) => {
            let id = member.id;
            console.log('Room member: ' + member.clientData.name + '-' + id);
            if (member.clientData.name == 'client') {
                rtcServerMap.set(id, new RTC_Client_Connection(id));
            }
        });
    });
    
    // Called when a new member joins the room
    room.on('member_join', newMember => {
        roomMembers.push(newMember);
        updateMembersDOM();
        let id = newMember.id;
        console.log('Joined room: ' + newMember.clientData.name + '-' + id);
        if (newMember.clientData.name == 'client') {
            rtcServerMap.set(id, new RTC_Client_Connection(id));
        }
    });
    
    // Called when a member leaves the room
    room.on('member_leave', ({id}) => {
        let index = roomMembers.findIndex(member => member.id === id);
        let leavingMember = roomMembers[index];
        leavingMemberName = leavingMember.clientData.name;
        console.log('Left room: ' + leavingMemberName + '-' + leavingMember.id);
        roomMembers.splice(index, 1);
        
        // Close out peer connections
        if (leavingMemberName == 'client') {
            rtcServerMap.get(id).pc.close();
            rtcServerMap.delete(id);
        }
        updateMembersDOM();
    });
    
    // Listen to signaling data from Scaledrone
    room.on('data', (message, sendingPeer) => {
        if(message.targetId !== drone.clientId) {
            return;
        }
        rtcServerMap.get(sendingPeer.id).reactToMessage(message, sendingPeer)
    });
});


// ---------------- Video and Audio Streaming Code ----------------

/**
 * This class is a wrapper for the WebRTC API that defines necessary
 * callbacks. Each instance of this class is associated with a specific
 * video streaming client, and contains an idStr which is the unique 
 * ScaleDrone Room ID for the particular client.
 */
class RTC_Client_Connection {
    idStr = '';
    pc = null;

    constructor(idStr) {
        this.idStr = idStr;
        this.pc = new RTCPeerConnection(ice_configuration);
        
        // 'onicecandidate' notifies us whenever an ICE agent needs to deliver a
        // message to the other peer through the signaling server
        this.pc.onicecandidate = event => {
            console.log(this.idStr + ' On ICE');
            if (event.candidate) {
                console.log(this.idStr + ' send ICE')
                this.sendMessage({'candidate': event.candidate});
            }
        };
    
        // Give the local stream to the WebRTC instance
        if (localStream != null) {
            this.pc.addStream(localStream);
        }
    }
    
    // This function defines behavior on receiving SDP and ICE messages
    reactToMessage(message, sendingPeer) {
        let peerName = sendingPeer.clientData.name + '-' + sendingPeer.id;
        
        // Actions for if message is SDP offer, ICE candidate
        if (message.sdp) {
            console.log(this.idStr + ' SDP Offer');
            let desc = new RTCSessionDescription(message.sdp);
            this.pc.setRemoteDescription(desc, () => { // When receiving an offer, answer it
                if (this.pc.remoteDescription.type === 'offer') {
                    this.pc.createAnswer()
                        .then(desc => this.localDescCreated(desc))
                        .catch(err => console.error(err));
                }
            }, err => console.error(err));
        }
        else if (message.candidate) { // Add new ICE candidate to remote description
            console.log(this.idStr + ' ICE Candidate');
            this.pc.addIceCandidate(
                new RTCIceCandidate(message.candidate), () => {}, () => {this.pc.restartIce()}
            );
        }
    }
    
    // This gets called when creating an offer and when answering one
    // It sets the local description, and then sends the local description in an SDP
    localDescCreated(desc) {
        console.log(this.idStr + ' Sending SDP')
        this.pc.setLocalDescription(desc)
            .then(this.sendMessage({'sdp': desc}))
            .catch(err => console.error(err));
    }
    
    // Send targeted signaling data via Scaledrone
    sendMessage(message) {
        message.targetId = this.idStr;
        drone.publish({
            room: observableRoomName,
            message
        });
    }
}

// ---------------- DOM API to keep html page up to date ----------------

const DOM = {
    membersCount: document.querySelector('.members-count'),
    membersList: document.querySelector('.members-list'),
};

function createMemberElement(member) {
    let idStr = member.id;//.clientData.name.toString();
    let textForDisplay = member.clientData.name + '-' + idStr;
    let el = document.createElement('div');
    el.appendChild(document.createTextNode(textForDisplay));
    el.className = 'member';
    return el;
}

// Update the current clients who are connected
function updateMembersDOM() {
    DOM.membersCount.innerText = roomMembers.length.toString() + ' members in room';
    
    DOM.membersList.innerHTML = '';
    roomMembers.forEach(member =>
        DOM.membersList.appendChild(createMemberElement(member))
    );
}