
// ---------------- Constants ----------------

/* Important global variables */
const DRONE_CLIENT_ID = 'INSERT_ID_HERE'; // ScaleDrone room id
let room; // Scaledrone room which we are subscribed to
let roomMembers = []; // Scaledrone room members
let clientsMap = new Map();

// Prompt user to enter the room hash. The hash is randomly generated by the
// server.
let roomHash = '';
while (true) {
    roomHash = prompt("Enter ScaleDrone room hash");
    if (roomHash != null && roomHash != "") {
        break;
    } 
    else {
        alert("Please enter a room hash");
    }
}
//let roomHash = 'smitty_werbenjagermanjensen';

// Subscribe to room (parameters to set)
const roomName = 'videostream-' + roomHash; // This hash code is what makes you need the URL. 
const observableRoomName = 'observable-' + roomName;

// Set location hash on the browser tab
if (!location.hash) {
    location.hash = '#' + roomHash;
}
document.getElementById("myHash").textContent = 'Hash: ' + roomHash;

// Configuration is passed to RTCPeerConnection instance. Use Google's STUN server
const ice_configuration = {
    iceServers: [
        { urls: 'stun:stun.l.google.com:19302' } // Google's public STUN server
    ]
};


// ---------------- Signalling Service Callbacks ----------------

const drone = new ScaleDrone(DRONE_CLIENT_ID, { data: { name: 'client' } });

// Subsribe to a Scaledrone room for signaling
drone.on('open', error => {
    if (error) {
        console.error(error);
        return;
    }
    
    // Subscribe to the ScaleDrone room.
    // Room name needs to be prefixed with 'observable-'
    room = drone.subscribe(observableRoomName);
    room.on('open', error => {
        if (error) {
            console.error(error);
        }
    });
    
    // Connected to room and receive array of members
    room.on('members', receivedMembers => {
        roomMembers = receivedMembers;
        updateMembersDOM();
        receivedMembers.forEach( (member) => {
            let id = member.id;
            console.log('Room member: ' + member.clientData.name + '-' + id);
            if (member.clientData.name == 'server') {
                addServer(member);
            }
        });
    });
    
    // Called when a new member joins the room
    room.on('member_join', newMember => {
        roomMembers.push(newMember);
        updateMembersDOM();
        let id = newMember.id;
        console.log('Joined room: ' + newMember.clientData.name + '-' + id);
        if (newMember.clientData.name == 'server') {
            addServer(newMember);
        }
    });
    
    // Called when a member leaves the room
    room.on('member_leave', ({id}) => {
        let index = roomMembers.findIndex(member => member.id === id);
        let leavingMember = roomMembers[index];
        leavingMemberName = leavingMember.clientData.name;
        console.log('Left room: ' + leavingMemberName + '-' + leavingMember.id);
        roomMembers.splice(index, 1);
        
        // Close out peer connections
        if (leavingMemberName == 'server') {
            removeServer(leavingMember);
        }
        updateMembersDOM();
    });
    
    // Listen to signaling data from Scaledrone
    room.on('data', (message, sendingPeer) => {
        if(message.targetId !== drone.clientId) {
            return;
        }
        clientsMap.get(sendingPeer.id).reactToMessage(message, sendingPeer)
    });
});


// ---------------- Video and Audio Streaming Code ----------------

const offerOptions = {offerToReceiveVideo: true, offerToReceiveAudio: false};

/**
 * This class is a wrapper for the WebRTC API that defines necessary
 * callbacks. Each instance of this class is associated with a specific
 * video streaming server, and contains an idStr which is the unique 
 * ScaleDrone Room ID for the particular server.
 */
class RTC_Server_Connection {
    idStr = '';
    pc = null;
    negotiationLock = false;
    
    constructor(idStr) {
        this.idStr = idStr;
    }
    
    startCall() {
        document.getElementById('startButton-' + this.idStr).disabled = true;
        document.getElementById('stopButton-' + this.idStr).disabled = false;
        
        this.pc = new RTCPeerConnection(ice_configuration);
        
        // ------ Set Callbacks ------
        
        // 'onicecandidate' notifies us whenever an ICE agent needs to deliver a
        // message to the other peer through the signaling server
        this.pc.onicecandidate = event => {
            if (event.candidate) {
                this.sendMessage({'candidate': event.candidate});
            }
        };
        
        // The user is an offerer (caller/client), let the 'negotiationneeded' event create the offer
        // This basically creates an SDP
        this.pc.onnegotiationneeded = () => {
            if (!this.negotiationLock) { // Lock guard for chrome bug
                this.negotiationLock = true;
                this.pc.createOffer({offerToReceiveVideo: true})
                    .then(desc => this.localDescCreated(desc))
                    .catch(err => console.error(err));
                this.negotiationLock = false;
            }
        }
        
        // When a remote stream arrives display it in the #remoteVideo element
        // ontrack lets you connect the incoming media to an elment to display
        this.pc.ontrack = event => { // This function is experimental and shouldn't be used!!
            let receivedStream = event.streams[0];
            let videoElem = document.getElementById('video-' + this.idStr);
            if (!videoElem.srcObject || videoElem.srcObject !== receivedStream) {
                console.log(this.idStr + ' Receiving remote stream');
                videoElem.srcObject = receivedStream;
            }
        };
        
        // This sends the SDP offer to receive video stream, basically starting the stream
        this.pc.createOffer(offerOptions)
            .then(desc => this.localDescCreated(desc))
            .then(console.log(this.idStr + ' Offer created'))
            .catch(err => console.error(err));
    }

    endCall() {
        this.pc.close();
        this.pc = null;
        delete(this.pc);
        document.getElementById('video-' + this.idStr).srcObject = null;
        document.getElementById('startButton-' + this.idStr).disabled = false;
        document.getElementById('stopButton-' + this.idStr).disabled = true;
    }
    
    // This function defines behavior on receiving SDP and ICE messages
    reactToMessage(message, sendingPeer) {
        let peerName = sendingPeer.clientData.name + '-' + sendingPeer.id;
    
        // Actions for if message is SDP offer, ICE candidate
        if (message.sdp) {
            console.log(this.idStr + ' SDP Offer');
            let desc = new RTCSessionDescription(message.sdp);
            this.pc.setRemoteDescription(desc, () => {}, err => console.error(err));
        }
        else if (message.candidate) { // Add new ICE candidate to remote description
            console.log(this.idStr + ' ICE Candidate');
            this.pc.addIceCandidate(
                new RTCIceCandidate(message.candidate), ()=>{}, () => {this.pc.restartIce()}
            );
        }
    }
    
    // this gets called when creating an offer and when answering one. It updates local description of connection
    localDescCreated(desc) {
        console.log(this.idStr + ' Sending SDP');
        this.pc.setLocalDescription(desc)
            .then(this.sendMessage({'sdp': desc}))
            .catch(err => console.error(err));
    }
    
    // Send only targeted signaling data via Scaledrone
    sendMessage(message) {
        message.targetId = this.idStr;
        drone.publish({
            room: observableRoomName,
            message
        });
    }
}

// ---------------- DOM API to keep html page up to date ----------------

const DOM = {
    membersCount: document.querySelector('.members-count'),
};

// This adds the box with the video and the buttons to start/stop the call
function addServer(member) {
    let idStr = member.id;
    let name = member.clientData.name + '-' + idStr;
    
    clientsMap.set(idStr, new RTC_Server_Connection(idStr));
    
    let el = document.createElement('div');
    el.className = 'streamview';
    el.id = 'streamview-' + idStr;
    
    let el_member = document.createElement('div');
    el_member.className = 'member';
    el_member.textContent = name;
    el.appendChild(el_member);
    
    let el_video = document.createElement('video');
    el_video.id = 'video-' + idStr;
    el_video.autoplay = true;
    el.appendChild(el_video);
    
    let el_startButton = document.createElement('button');
    el_startButton.id = 'startButton-' + idStr;
    el_startButton.textContent = 'Start';
    el_startButton.onclick = () => clientsMap.get(idStr).startCall();
    el_startButton.disabled = false;
    el.appendChild(el_startButton);

    let el_stopButton = document.createElement('button');
    el_stopButton.id = 'stopButton-' + idStr;
    el_stopButton.textContent = 'Stop';
    el_stopButton.onclick = () => clientsMap.get(idStr).endCall();
    el_stopButton.disabled = true;
    el.appendChild(el_stopButton);
    
    document.body.append(el);
    return;
}

function removeServer(member) {
    let idStr = member.id;
    let name = member.clientData.name + '-' + idStr;
    
    // TODO
    let el = document.getElementById('streamview-' + idStr);
    el.parentNode.removeChild(el);
    
    clientsMap.delete(idStr);
}

// Update the current clients who are connected
function updateMembersDOM() {
    DOM.membersCount.innerText = roomMembers.length.toString() + ' members in room';
}
